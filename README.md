# Spotify: EDA, Visualization and Building a Recommendation System
## Data Scraping
Используемый набор данных Spotify представляет собой "Million Playlist Dataset" (MPD), содержащий 1 миллион плейлистов, созданных пользователями Spotify. Этот набор данных был разделен на 1000 файлов по 1000 плейлистов в каждом, в общей сложности 1 000 000 плейлистов. Из-за огромных размеров набора данных было решено использовать только 6 файлов `JSON` и работать с определенными важными функциями, которые извлекаются с помощью вызовов API Spotify. Представленный в репозитории ноутбук показывает процесс обратоки одного такого `JSON` файла.

Spotify структурирует свои данные, относящиеся к каждой песне, в четыре объекта: объект трека, объект исполнителя, объект альбома и объект звуковых признаков. Эти объекты содержат различную информацию о песне, такую как ее название, исполнитель, альбом и количественные данные, такие как энергия и акустичность.

Для сбора данных использовался метод запроса всех четырех объектов, соответствующих каждой песне в плейлисте, на которую ссылались через URI. Однако этот метод сбора данных столкнулся с несколькими проблемами с точки зрения масштабируемости:
- Для получения объектов требовался токен аутентификации, который необходимо было периодически обновлять, что ограничивало временные рамки для сбора данных.
- Spotify блокировал токены, которые слишком часто обращались к конечным точкам API, что вынуждало использовать более медленные мобильные точки доступа для обхода этого механизма блокировки.
- В процессе сбора данных происходили случайные остановки из-за ошибок запросов.

В результате этих проблем удалось извлечь более 32 000 песен из плейлистов, что составляет 19 000 песен после удаления дубликатов. Этот значительный объем данных, однако, не включает данные для всех существующих в Spotify песен, что потребовало разработки моделей с определенными обходными путями.

## Моделирование и результаты
*Модель 1*: Первая модель была проверена на основе обратной связи людей. Факт того, что вся модель основана на вмешательстве человека, делает ее немного проще для проверки работы нашей модели. Наша система рекомендаций довольно хорошо сработала с этим подходом. Идея заставить пользователя оценивать песни, а затем обучать модель на основе этих выборов песен, породила список вероятных аудио-характеристик, которые пользователь подсознательно предпочитает, практична, жизнеспособна и реализуема. Практический аспект этого подхода делает его очень подходящим хотя бы для небольших наборов данных. Проблема "холодного старта" была решена с помощью этого подхода. В случае, если у пользователя нет предварительного плейлиста с добавленными в него треками, этот подход будет работать нормально. Однако эта рекомендационная система определенно будет работать лучше, если у пользователя есть какой-то начальный плейлист с добавленными к нему "оцененными" треками, чтобы рекомендации были еще более персонализированными и лучше.

*Модель 2*: Второй подход был проверен на основе оценок CV. В этом подходе мы решили проблему с помощью классической бинарной модели классификации. Мы добавили дополнительный столбец в наш набор данных под названием "in_playlist", который является бинарным: 0 означает, что трек не в плейлисте, а 1 означает, что трек присутствует в плейлисте. Мы построили модели логистической регрессии, случайного леса, градиентного бустинга и метода ближайших соседей для классификации треков. Мы разделили набор данных на обучающую/тестовую выборки и провели кросс-валидацию с 10 фолдами на каждой из моделей. Мы сгенерировали значения R2-ошибки и сравнили их. Кросс-валидационные оценки использовались для проверки сгенерированных ошибок. Кроме того, мы использовали кросс-валидацию, чтобы получить оптимальное количество соседей для нашей модели метода ближайших соседей. В целом, после сравнений мы обнаружили, что у случайного леса точность на тестовом наборе данных составляет около 0.99, что делает его выдающейся моделью. Поскольку мы провели кросс-валидацию, риск переобучения модели также снижен. Все оценки и меры хорошо документированы в ноутбуках Jupyter.
